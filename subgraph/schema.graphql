type Ipnft @entity {
  id: ID! #tokenId
  owner: Bytes! # address
  createdAt: BigInt!
  tokenURI: String!
  listings: [Listing!] @derivedFrom(field: "ipnft")
  symbol: String
  readers: [CanRead!] @derivedFrom(field: "ipnft")
  fractions: [Fractions!] @derivedFrom(field: "ipnft")
}

type Fractions @entity {
  id: ID! # fractionId
  ipnft: Ipnft!
  txHash: Bytes
  originalOwner: Bytes! # address of the issuer
  initialAmount: BigInt! # initial amount of tokens
  createdAt: BigInt!
}

type FracIpnft @entity {
  id: ID! #fractionId - hash of original Owner + collection address + tokenId
  originalOwner: Bytes! #address
  createdAt: BigInt!
  ipnftId: ID # tokenID of original Ipnft
  agreementCid: String #IPFS CID string of FAM Agreement
  totalIssued: BigInt! #the amount of fractions issued; can be increased later
  circulatingSupply: BigInt! #the amount of fractions that are in circulation
  claimedShares: BigInt! # the amount of shares that have already been claimed. This needs to have a fulfilledListingId to be set
  paymentToken: Bytes #address ERC20 Token
  paidPrice: BigInt #the price paid for the original ipnft
  baskets: [FracBasket!] @derivedFrom(field: "fracIpnft")
}

# Name tbd
type FracBasket @entity {
  id: ID! # fractionId + owner address
  fracIpnft: FracIpnft!
  balance: BigInt! # Token balance of the owner
  owner: Bytes! #Address of the token owner
  agreementSigned: Boolean! #if the owner has signed the agreement
}

type Listing @entity {
  id: ID!
  ipnft: Ipnft!
  creator: Bytes! #address
  tokenAmount: BigInt! #the amount of this token to sell, usually 1
  paymentToken: Bytes! #address ERC20 Token
  askPrice: BigInt!
  createdAt: BigInt!
  unlistedAt: BigInt
  purchasedAt: BigInt
  buyer: Bytes #address
  allowed: [Allowed!] @derivedFrom(field: "listing")
}

type CanRead @entity {
  id: ID! #keccak(tokenId,address)
  ipnft: Ipnft!
  reader: Bytes! #address
  until: BigInt
}

type Allowed @entity {
  id: ID! #listingid-account
  account: Bytes!
  listing: Listing!
  allowed: Boolean!
}

type Reservation @entity {
  id: ID! #reservationId will be future tokenId
  owner: Bytes! #address
  uri: String
  createdAt: BigInt!
}

enum MintpassStatus {
  DEFAULT
  REDEEMED
  REVOKED
}

type Mintpass @entity {
  id: ID! #tokenId
  owner: Bytes! #address
  createdAt: BigInt!
  status: MintpassStatus
}
